import java_cup.runtime.*;
import java.util.ArrayList;


parser code
{:
    public static Nodo padre;
    public static ArrayList<String> ErroresSintacticos = new ArrayList<String>();
    public int cont = 0;
    public void syntax_error (Symbol s) {
        System.out.println("Error de sintaxis: \""+ s.value + "\" Linea: " + (s.right+1) + " Columna: " + (s.left+1));
        ErroresSintacticos.add("Error de sintaxis: \""+ s.value + "\" Linea: " + (s.right+1) + " Columna: " + (s.left+1));
    }

    public void unrecovered_syntax_error (Symbol s) throws java.lang.Exception {
        System.out.println("Error No Recuperable de sintaxis: \""+ s.value + "\" Linea: " + (s.right+1) + " Columna: " + (s.left+1));
        ErroresSintacticos.add("Error No Recuperable de sintaxis: \""+ s.value + "\" Linea: " + (s.right+1) + " Columna: " + (s.left+1));
    }

:}

// Terminales
terminal PROCEDURE, FUNCTION, RETURN, CONSTANT, IS, BEGIN, END, IF, THEN, ELSE, ELSIF, FOR, IN, OUT, WHILE, LOOP;
terminal AND,OR,XOR,FALSE,TRUE,EXIT,WHEN,NULL,GET,PUT;
terminal INTEGER,FLOAT,BOOLEAN,CHARACTER,STRINGTYPE;
terminal ASIGNACION,DECLARACION,OPREL,OPMULTIPLICACION,OPSUMA,PARDER,PARIZQ,SEMICOLON,COMA, DOSPUNTOS;
terminal String ID;
terminal String NUM;
terminal String STRING,CHAR;

// No Terminales
non terminal inicio, cuerpo_principal, comienza_cuerpo_principal;
non terminal parametros, datos_parametros, tipo_parametro, tipo_declaracion, declarar_procedimiento, declarar_funcion, llamar_funcion, funcion, declarar_variable;
non terminal tipo_variable, listar_ids;
non terminal codigo;
non terminal condicion, operando, expresion_booleana;
non terminal ciclo_loop, ciclo_for, ciclo_while, salir_ciclo, bloque_if, bloque_elsif, bloque_else, procedimiento;
non terminal expresion_aritmetica, E, E_prima, T, T_prima, F;
non terminal asignacion,get,put;

// Tipos de datos para Tabla de Símbolos
terminal Intger ENTERO;
terminal Float NUMFLOAT;
terminal String TEXTO;
terminal Boolean BOOLEANO;

// Precedencia de Operadores - de menor a mayor
precedence left OPREL;
precedence left OPSUMA;
precedence left OPMULTIPLICACION;

// Gramatica

start with inicio;

/* Cuerpo principal contiene el procedimiento o la funcion principal.
Declaramos primero un procedure y una function en su forma principal.*/
inicio  ::= cuerpo_principal:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("Inicio", parser.cont);
        parser.cont++;

        /*Se añaden el hijo*/
        nodo.AddHijo((Nodo) child1);

        /*Solamente en el cuerpo inicial se le asigna el nodo principal al padre.*/
        parser.padre = (Nodo) nodo;

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        ;

cuerpo_principal    ::= PROCEDURE:n1 ID:n2 parametros:child1 IS:n3 comienza_cuerpo_principal:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("cuerpo_principal", parser.cont);
                    parser.cont++;
                    
                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoProcedure = new Nodo("PROCEDURE", n1.toString(), parser.cont );
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoId = new Nodo("ID",n2.toString(),parser.cont);
                    parser.cont++;

                                        
                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoProcedure);
                    nodo.AddHijo(nodoId);
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | error ID:n2 parametros:child1 IS:n3 comienza_cuerpo_principal:child2
                    | PROCEDURE:n1 error parametros:child1 IS:n3 comienza_cuerpo_principal:child2
                    | PROCEDURE:n1 ID:n2 parametros:child1 error comienza_cuerpo_principal:child2
                    | PROCEDURE:n1 ID:n2 IS:n3 comienza_cuerpo_principal:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("cuerpo_principal",parser.cont);
                    parser.cont++;
                    
                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoProcedure = new Nodo("PROCEDURE", n1.toString(),parser.cont );
                    parser.cont++;
                    
                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoProcedure);
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    
                    :}
                    | error ID:n2 IS:n3 comienza_cuerpo_principal:child1
                    | PROCEDURE:n1 error IS:n3 comienza_cuerpo_principal:child1
                    | PROCEDURE:n1 ID:n2 error comienza_cuerpo_principal:child1
                    | FUNCTION:n1 ID:n2 parametros:child1 RETURN:n3 tipo_variable:child2 IS:n4 comienza_cuerpo_principal:child3 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("cuerpo_principal",parser.cont);
                    parser.cont++;
                    
                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoFunction = new Nodo("FUNCTION", n1.toString(),parser.cont );
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoIs = new Nodo("IS", n4.toString(), parser.cont);
                    parser.cont++;
                    
                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoFunction);
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    nodo.AddHijo((Nodo) child3);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | error ID:n2 parametros:child1 RETURN:n3 tipo_variable:child2 IS:n4 comienza_cuerpo_principal:child3
                    | FUNCTION:n1 error parametros:child1 RETURN:n3 tipo_variable:child2 IS:n4 comienza_cuerpo_principal:child3
                    | FUNCTION:n1 ID:n2 parametros:child1 error tipo_variable:child2 IS:n4 comienza_cuerpo_principal:child3
                    | FUNCTION:n1 ID:n2 parametros:child1 RETURN:n3 tipo_variable:child2 error comienza_cuerpo_principal:child3
                    ; 

/*Este es el área donde comenzará el codigo del programa.*/
comienza_cuerpo_principal   ::= tipo_declaracion:child1 BEGIN:n1 codigo:child2 END:n2 ID:n3 SEMICOLON:n4 {:
                            /*Se crea el nodo prinicipal*/
                            Nodo nodo = new Nodo("comienza_cuerpo_principal",parser.cont);
                            parser.cont++;
                            
                            /*Se añaden los hijos*/
                            nodo.AddHijo((Nodo) child1);
                            nodo.AddHijo((Nodo) child2);

                            /*Asignar el nodo al RESULT para continuar el recorrido*/
                            RESULT = nodo;
                            :}
                            | tipo_declaracion:child1 error codigo:child2 END:n2 ID:n3 SEMICOLON:n4
                            | tipo_declaracion:child1 BEGIN:n1 codigo:child2 error ID:n3 SEMICOLON:n4
                            | tipo_declaracion:child1 BEGIN:n1 codigo:child2 END:n2 error SEMICOLON:n4
                            | tipo_declaracion:child1 BEGIN:n1 codigo:child2 END:n2 ID:n3 error

                            | BEGIN:n1 codigo:child1 END:n2 ID:n3 SEMICOLON:n4 {:
                            /*Se crea el nodo prinicipal*/
                            Nodo nodo = new Nodo("comienza_cuerpo_principal",parser.cont);
                            parser.cont++;
                            
                            /*Se añaden los hijos*/
                            nodo.AddHijo((Nodo) child1);

                            /*Asignar el nodo al RESULT para continuar el recorrido*/
                            RESULT = nodo;
                            :}
                            | 
                            | error codigo:child1 END:n2 ID:n3 SEMICOLON:n4
                            | BEGIN:n1 codigo:child1 error ID:n3 SEMICOLON:n4
                            | BEGIN:n1 codigo:child1 END:n2 error SEMICOLON:n4
                            | BEGIN:n1 codigo:child1 END:n2 ID:n3 error

                            ;
/*Esta es la forma en la que ese presenta el código. Se podrá poner cualquiera de estas opciones
para comenzar a declarar código.*/
codigo  ::= ciclo_for:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | ciclo_for:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | ciclo_while:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo",parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | ciclo_while:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo",parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);


        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | ciclo_loop:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo",parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | ciclo_loop:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo",parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);


        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | bloque_if:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo",parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | bloque_if:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | get:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | get:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);


        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | put:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | put:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | asignacion:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | asignacion:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | llamar_funcion:child1 codigo:child2 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | llamar_funcion:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("codigo", parser.cont);
        parser.cont++;
 
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);

        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;

        :}
        | RETURN expresion_aritmetica:child1 SEMICOLON
        {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("codigo", parser.cont);
            parser.cont++;
    
            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
        :}
        | RETURN expresion_aritmetica:child1 
        {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("codigo", parser.cont);
            parser.cont++;
    
            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
        :}
        ;

/*Estos son los parámetros para procedimientos.*/
parametros  ::=  PARIZQ datos_parametros:child1 PARDER {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("parametros", parser.cont );
            parser.cont++;
    
            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | PARIZQ PARDER:n2 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("parametros", parser.cont );
            parser.cont++;

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            ;

/*Estos son los datos de los paáametros.*/
datos_parametros    ::= listar_ids:child1 DECLARACION tipo_parametro:child2 tipo_variable:child3 SEMICOLON datos_parametros:child4 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("datos_parametros", parser.cont);
                    parser.cont++;

                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    nodo.AddHijo((Nodo) child3);
                    nodo.AddHijo((Nodo) child4);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | listar_ids:child1 error tipo_parametro:child2 tipo_variable:child3 SEMICOLON datos_parametros:child4
                    | listar_ids:child1 DECLARACION tipo_parametro:child2 tipo_variable:child3 error datos_parametros:child4
                    | listar_ids:child1 DECLARACION tipo_parametro:child2 tipo_variable:child3 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("datos_parametros", parser.cont);
                    parser.cont++;
                
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    nodo.AddHijo((Nodo) child3);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | listar_ids:child1 error tipo_parametro:child2 tipo_variable:child3
                    | expresion_aritmetica:child1 
                    {:
                        Nodo nodo = new Nodo("datos_parametros", parser.cont);
                        parser.cont++;
                        nodo.AddHijo((Nodo) child1);

                        RESULT = nodo;
                    :}
                    ;
// Aquí se definen los tipos de parámetros que pueden ser IN, OUT, IN OUT o ninguno.
tipo_parametro  ::= IN:n1 {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_parametro", n1.toString(), parser.cont);
                parser.cont++;
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | OUT:n2 {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_parametro", n2.toString(), parser.cont);
                parser.cont++;
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | error
                | IN:n1 OUT:n2 {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_parametro", parser.cont);
                parser.cont++;

                /*Nuevo Nodo: TERMINAL*/
                Nodo nodoIn = new Nodo("IN",n1.toString(), parser.cont);
                parser.cont++;

                /*Nuevo Nodo: TERMINAL*/
                Nodo nodoOut = new Nodo("OUT",n2.toString(), parser.cont);
                parser.cont++;

                /*Se añaden los hijos*/
                nodo.AddHijo(nodoIn);
                nodo.AddHijo(nodoOut);

                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("VACIO", parser.cont );
                parser.cont++;
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;

                :}
                | error OUT:n2
                | IN:n1 error
                ;

/*Aquí permitimos listar los identificadores. La razón por la cual se tiene listar_ids
y declaracion_variables es porque en declarar_variable se puede, valga la redundancia,
declarar variables.*/
listar_ids  ::= ID:n1 COMA:n2 listar_ids:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("listar_ids", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(),parser.cont );
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoComa = new Nodo("COMA",n2.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoComa);
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | error COMA:n2 listar_ids:child1
            | ID:n1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("listar_ids", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont );
            parser.cont++;


            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;

            :}
            | error
            ;                    

/*Aquí tenemos los tipos de declaraciones que se pueden hacer en el programa. Se pone
procedimiento y declaracion procedimiento como dos diferentes porque la declaracion
de un procedimiento es mas corta que un procedimiento en si, igual que la funcion.*/
tipo_declaracion    ::= declarar_variable:child1 tipo_declaracion:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | declarar_variable:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | declarar_funcion:child1 tipo_declaracion:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | declarar_funcion:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | declarar_procedimiento:child1 tipo_declaracion:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | declarar_procedimiento:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | llamar_funcion:child1 tipo_declaracion:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | llamar_funcion:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | procedimiento:child1 tipo_declaracion:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | procedimiento:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                    parser.cont++;
            
                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | asignacion:child1 tipo_declaracion:child2
                    {:
                        Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                        parser.cont++;

                        nodo.AddHijo((Nodo) child1);
                        nodo.AddHijo((Nodo) child2);

                        RESULT = nodo;
                    :}
                    | asignacion:child1
                    {:
                        Nodo nodo = new Nodo("tipo_declaracion", parser.cont);
                        parser.cont++;

                        nodo.AddHijo((Nodo) child1);

                        RESULT = nodo;
                    :}
                    ;

/*Aquí declaramos un procedimiento y luego están las versiones con error.*/
declarar_procedimiento  ::= PROCEDURE:n1 ID:n2 parametros:child1 SEMICOLON {:
                        /*Se crea el nodo prinicipal*/
                        Nodo nodo = new Nodo("declarar_procedimiento", parser.cont);
                        parser.cont++;

                        /*Nuevo Nodo: TERMINAL*/
                        Nodo nodoId = new Nodo("ID", n2.toString(), parser.cont );
                        parser.cont++;

                        /*Se añaden los hijos*/
                        nodo.AddHijo(nodoId);
                        nodo.AddHijo((Nodo) child1);

                        /*Asignar el nodo al RESULT para continuar el recorrido*/
                        RESULT = nodo;

                        :}
                        | PROCEDURE:n1 error parametros:child1 SEMICOLON
                        | PROCEDURE:n1 ID:n2 parametros:child1 error
                        ;

procedimiento   ::= PROCEDURE ID:n2 parametros:child1 IS tipo_declaracion:child2 BEGIN codigo:child3 END ID:n6 SEMICOLON {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("procedimiento", parser.cont);
                parser.cont++;

                /*Nuevo Nodo: TERMINAL*/
                Nodo nodoId = new Nodo("ID", n2.toString(), parser.cont);
                parser.cont++;

                /*Nuevo Nodo: TERMINAL*/
                Nodo nodoId2 = new Nodo("ID", n6.toString(), parser.cont);
                parser.cont++;

                /*Se añaden los hijos*/
                nodo.AddHijo(nodoId);
                nodo.AddHijo((Nodo) child1);
                nodo.AddHijo((Nodo) child2);
                nodo.AddHijo((Nodo) child3);
                nodo.AddHijo(nodoId2);

                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | PROCEDURE error parametros:child1 IS tipo_declaracion:child2 BEGIN codigo:child3 END ID:n6 SEMICOLON
                | PROCEDURE ID:n2 parametros:child1 IS BEGIN codigo:child2 END ID:n6 SEMICOLON
                {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("procedimiento", parser.cont);
                parser.cont++;

                /*Nuevo Nodo: TERMINAL*/
                Nodo nodoId = new Nodo("ID", n2.toString(), parser.cont);
                parser.cont++;

                /*Se añaden los hijos*/
                nodo.AddHijo(nodoId);
                nodo.AddHijo((Nodo) child1);
                nodo.AddHijo((Nodo) child2);

                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;                
                :}
                | PROCEDURE error parametros:child1 IS BEGIN codigo:child2 END ID:n6 SEMICOLON
                ;

declarar_funcion    ::= FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 END ID:n2 SEMICOLON {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("declarar_funcion", parser.cont);
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
                    parser.cont++;

                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoId);
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    nodo.AddHijo((Nodo) child3);
                    nodo.AddHijo((Nodo) child4);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | FUNCTION error parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 error tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 error tipo_declaracion:child3 BEGIN codigo:child4 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 error codigo:child4 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 error ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 END error SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS tipo_declaracion:child3 BEGIN codigo:child4 END ID:n2 error
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS BEGIN codigo:child3 END ID:n2 SEMICOLON {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("declarar_funcion", parser.cont);
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
                    parser.cont++;

                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoId);
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo((Nodo) child2);
                    nodo.AddHijo((Nodo) child3);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | FUNCTION error parametros:child1 RETURN tipo_variable:child2 IS BEGIN codigo:child3 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 error tipo_variable:child2 IS BEGIN codigo:child3 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 error BEGIN codigo:child3 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS error codigo:child3 END ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS BEGIN codigo:child3 error ID:n2 SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS BEGIN codigo:child3 END error SEMICOLON
                    | FUNCTION ID:n1 parametros:child1 RETURN tipo_variable:child2 IS BEGIN codigo:child3 END ID:n2 error
                    ;

/*Llamar Funcion: Estructura de la funcion + el Punto y Coma
Funcion: El ID (Nombre de la funcion) y la non terminal parametros 
(La cual incluye: PARIZQ datos_parametros PARDER).*/
llamar_funcion  ::= funcion:child1 SEMICOLON {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("llamar_funcion", parser.cont);
                parser.cont++;
               
                /*Se añaden los hijos*/
                nodo.AddHijo((Nodo) child1);

                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | funcion:child1 error
                ;

funcion ::= ID:n1 parametros:child1 {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("funcion", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoId);
        nodo.AddHijo((Nodo) child1);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        ;


/*Aquí tenemos la opción de declarara una o más variables. Luego están las versiones
con errores.*/
declarar_variable   ::= ID:n1 COMA:n2 declarar_variable:child1 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("declarar_variable", parser.cont);
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
                    parser.cont++;

                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoId);
                    nodo.AddHijo((Nodo) child1);
                    
                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | ID:n1 error declarar_variable:child1
                    | ID:n1 DECLARACION:n2 tipo_variable:child1 SEMICOLON {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("declarar_variable", parser.cont);
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
                    parser.cont++;
                    
                    /*Se añaden los hijos*/
                    nodo.AddHijo(nodoId);
                    nodo.AddHijo((Nodo) child1);

                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | ID:n1 error tipo_variable:child1 SEMICOLON
                    | ID:n1 DECLARACION:n2 tipo_variable:child1 error
                    ;

/*Asignación de un valor a una variable*/
asignacion  ::= ID:n1 COMA:n2 asignacion:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error asignacion:child1
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 expresion_aritmetica:child2 SEMICOLON:n4 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error tipo_variable:child1 ASIGNACION:n3 expresion_aritmetica:child2 SEMICOLON:n4
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 expresion_aritmetica:child2 error
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 TRUE:n4 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoTrue = new Nodo("TRUE", n4.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoTrue);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error tipo_variable:child1 ASIGNACION:n3 TRUE:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 error TRUE:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 error SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 TRUE:n4 error
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 FALSE:n4 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;
            
            Nodo nodoFalse = new Nodo("FALSE", n4.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoFalse);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error tipo_variable:child1 ASIGNACION:n3 FALSE:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 error FALSE:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 FALSE:n4 error
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 STRING:n4 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID",n1.toString(), parser.cont);
            parser.cont++;
       
            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoString = new Nodo("STRING", n4.toString().replaceAll("\"", ""), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoString);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error tipo_variable:child1 ASIGNACION:n3 STRING:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 error STRING:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 STRING:n4 error
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 CHAR:n4 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoChar = new Nodo("CHAR", n4.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoChar);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error tipo_variable:child1 ASIGNACION:n3 CHAR:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 error CHAR:n4 SEMICOLON
            | ID:n1 DECLARACION:n2 tipo_variable:child1 ASIGNACION:n3 CHAR:n4 error
            | ID:n1 ASIGNACION:n2 expresion_aritmetica:child1 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo((Nodo) child1);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error expresion_aritmetica:child1 SEMICOLON
            | ID:n1 ASIGNACION:n2 expresion_aritmetica:child1 error
            | ID:n1 ASIGNACION:n2 TRUE:n3 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoTrue = new Nodo("TRUE", n3.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoTrue);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error TRUE:n3 SEMICOLON
            | ID:n1 ASIGNACION:n2 error SEMICOLON
            | ID:n1 ASIGNACION:n2 TRUE:n3 error
            | ID:n1 ASIGNACION:n2 FALSE:n3 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoFalse = new Nodo("FALSE", n3.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoFalse);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error FALSE:n3 SEMICOLON
            | ID:n1 ASIGNACION:n2 FALSE:n3 error
            | ID:n1 ASIGNACION:n2 STRING:n3 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoString = new Nodo("STRING",n3.toString().replaceAll("\"", ""), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoString);         

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error STRING:n3 SEMICOLON
            | ID:n1 ASIGNACION:n2 STRING:n3 error
            | ID:n1 ASIGNACION:n2 CHAR:n3 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoChar = new Nodo("CHAR", n3.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoChar); 

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CHAR:n3 SEMICOLON
            | ID:n1 ASIGNACION:n2 CHAR:n3 error
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 expresion_aritmetica:child2 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoConstant = new Nodo("CONSTANT", n3.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoConstant);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 expresion_aritmetica:child2 SEMICOLON
            | ID:n1 DECLARACION:n2 error tipo_variable:child1 ASIGNACION:n4 expresion_aritmetica:child2 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 error expresion_aritmetica:child2 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 expresion_aritmetica:child2 error
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 TRUE:n5 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoConstant = new Nodo("CONSTANT", n3.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoTrue = new Nodo("TRUE", n5.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoConstant);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoTrue);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 TRUE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 error tipo_variable:child1 ASIGNACION:n4 TRUE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 error TRUE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 error SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 TRUE:n5 error
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 FALSE:n5 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoConstant = new Nodo("CONSTANT", n3.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoFalse = new Nodo("FALSE", n5.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoConstant);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoFalse);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 FALSE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 error tipo_variable:child1 ASIGNACION:n4 FALSE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 error FALSE:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 FALSE:n5 error
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 STRING:n5 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoConstant = new Nodo("CONSTANT", n3.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoString = new Nodo("STRING", n5.toString().replaceAll("\"", ""), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoConstant);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoString);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 STRING:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 error tipo_variable:child1 ASIGNACION:n4 STRING:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 error STRING:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 STRING:n5 error
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 CHAR:n5 SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("asignacion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoConstant = new Nodo("CONSTANT", n3.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoChar = new Nodo("CHAR", n5.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoConstant);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoChar);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 error CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 CHAR:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 error tipo_variable:child1 ASIGNACION:n4 CHAR:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 error CHAR:n5 SEMICOLON
            | ID:n1 DECLARACION:n2 CONSTANT:n3 tipo_variable:child1 ASIGNACION:n4 CHAR:n5 error
            ;

/*OPERACIONES ARITMETICA POST ORDER*/
expresion_aritmetica    ::= E:child1 
                        {:
                            /*Se crea el nodo prinicipal*/
                            Nodo nodo = new Nodo("expresion_aritmetica", parser.cont);
                            parser.cont++;

                            /*Se añaden los hijos*/
                            nodo.AddHijo((Nodo) child1);
                            
                            /*Asignar el nodo al RESULT para continuar el recorrido*/
                            RESULT = nodo;
                        :}
                        ;
E   ::= T:child1 E_prima:child2 
    {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("E", parser.cont);
        parser.cont++;
        
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
    :}
    ;

E_prima ::= OPSUMA:n1 T:child1 E_prima:child2 
        {:
            Nodo nodo = new Nodo("E_prima", parser.cont);
            parser.cont++;
            
            Nodo nodoOPSUMA = new Nodo("OPSUMA", n1.toString(), parser.cont);
            parser.cont++;

            nodo.AddHijo(nodoOPSUMA);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);

            RESULT = nodo;
        :}
        | 
        {:
            Nodo nodo = new Nodo("VACIO", parser.cont);
            parser.cont++;
            RESULT = nodo;
        :}
        ;

T   ::= F:child1 T_prima:child2 
    {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("T", parser.cont);
        parser.cont++;
        
        /*Se añaden los hijos*/
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo((Nodo) child2);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
    :}
    ;

T_prima ::= OPMULTIPLICACION:n1 F:child1 T_prima:child2 
        {:
            Nodo nodo = new Nodo("T_prima", parser.cont);
            parser.cont++;
            
            Nodo nodoMult = new Nodo("OPMULTIPLICACION", n1.toString(), parser.cont);
            parser.cont++;

            nodo.AddHijo(nodoMult);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);

            RESULT = nodo;
        :}
        |
        {:
            Nodo nodo = new Nodo("VACIO", parser.cont);
            parser.cont++;

            RESULT = nodo;
        :}
        ;

F   ::= ID:n1 
    {:
        Nodo nodo = new Nodo("ID", n1.toString(), parser.cont);
        parser.cont++;

        RESULT = nodo;
    :}
    | NUM:n1 
    {:
        
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("NUM", n1.toString(), parser.cont);
        parser.cont++;
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
    :}
    | PARIZQ:n1 expresion_aritmetica:child1 PARDER:n2 
    {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("F", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoParizq = new Nodo("PARIZQ", n1.toString(), parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoParder = new Nodo("PARDER", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoParizq);
        nodo.AddHijo((Nodo) child1);
        nodo.AddHijo(nodoParder);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
    :}
    | llamar_funcion:child1
    {:
        Nodo nodo = new Nodo("F", parser.cont);
        parser.cont++;

        nodo.AddHijo((Nodo) child1);

        RESULT = nodo;
    :}
    ;


// Estos son los tipos de variable que se permiten en el programa.
tipo_variable   ::= INTEGER  {: 
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_variable", "INTEGER", parser.cont);
                parser.cont++;
                
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | FLOAT {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_variable", "FLOAT", parser.cont);
                parser.cont++;
                
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                
                :}
                | BOOLEAN {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_variable", "BOOLEAN", parser.cont);
                parser.cont++;
                
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                
                :}
                | STRINGTYPE {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_variable", "STRINGTYPE", parser.cont);
                parser.cont++;
                
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                
                :}
                | CHARACTER {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("tipo_variable", "CHARACTER", parser.cont);
                parser.cont++;
                
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                
                :}
                ;

/*================================BLOQUE IF======================================*/
/*BLOQUE IF: Estructura de un bloque if que internamente manda a llamar non terminales de
bloque elseif y del bloque else.*/
bloque_if   ::= IF condicion:child1 THEN codigo:child2 bloque_elsif:child3 bloque_else:child4 END IF SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("bloque_if", parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
            nodo.AddHijo((Nodo) child3);
            nodo.AddHijo((Nodo) child4);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | IF condicion:child1 error codigo:child2 bloque_elsif:child3 bloque_else:child4 END IF SEMICOLON
            | IF condicion:child1 THEN codigo:child2 bloque_elsif:child3 bloque_else:child4 error IF SEMICOLON
            | IF condicion:child1 THEN codigo:child2 bloque_elsif:child3 bloque_else:child4 END error SEMICOLON
            | IF condicion:child1 THEN codigo:child2 bloque_elsif:child3 bloque_else:child4 END IF error
            ;

//CONDICION = Condicion interna para los ifs y los ciclos loop y while.
condicion   ::= expresion_booleana:child1 OR:n1 condicion:child2 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("condicion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoOr = new Nodo("OR", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoOr);
            nodo.AddHijo((Nodo) child2);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | expresion_booleana:child1 AND:n1 condicion:child2 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("condicion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoAnd = new Nodo("AND", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoAnd);
            nodo.AddHijo((Nodo) child2);
            
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | expresion_booleana:child1 XOR:n1 condicion:child2 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("condicion", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoXor = new Nodo("XOR", n1.toString(), parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo(nodoXor);
            nodo.AddHijo((Nodo) child2);
            
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | expresion_booleana:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("expresion_booleana", parser.cont);
            parser.cont++;     

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            ;

//EXPRESION BOOLEANA: Expresion booleana en el que se comparan dos operandos con un operador relacional.
expresion_booleana  ::= operando:child1 OPREL:n1 operando:child2 {:
                    /*Se crea el nodo prinicipal*/
                    Nodo nodo = new Nodo("expresion_booleana", parser.cont);
                    parser.cont++;

                    /*Nuevo Nodo: TERMINAL*/
                    Nodo nodoOPREL = new Nodo("OPREL", n1.toString(), parser.cont);
                    parser.cont++;

                    /*Se añaden los hijos*/
                    nodo.AddHijo((Nodo) child1);
                    nodo.AddHijo(nodoOPREL);
                    nodo.AddHijo((Nodo) child2);
                    
                    
                    /*Asignar el nodo al RESULT para continuar el recorrido*/
                    RESULT = nodo;
                    :}
                    | operando:child1 error operando:child2
                    ;

//OPERANDO: Operandos Relacionales utilizados en la expresion booleana.
operando    ::= NUM:n1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("NUM", n1.toString(), parser.cont);
            parser.cont++;
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | ID:n1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | error
            | funcion:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("operando", parser.cont);
            parser.cont++;
            
            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | CHAR:n1
            {:
                Nodo nodo = new Nodo("CHAR", n1.toString());
                parser.cont++;

                RESULT = nodo;
            :}
            | NULL {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("operando", "NULL", parser.cont);
            parser.cont++;
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            ;

/*Bloque ELSEIF y Bloque ELSE que vienen del bloque if. Este puede incluir vacio ya que
no en todos los ifs se requiere un bloque else if.*/
bloque_elsif    ::= ELSIF condicion:child1 THEN codigo:child2 bloque_elsif:child3 {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("bloque_elsif", parser.cont);
                parser.cont++;
                
                /*Se añaden los hijos*/
                nodo.AddHijo((Nodo) child1);
                nodo.AddHijo((Nodo) child2);
                nodo.AddHijo((Nodo) child3);

                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("VACIO", parser.cont);
                parser.cont++;
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;
                :}
                | ELSIF condicion:child1 error codigo:child2 bloque_elsif:child3
                ;

bloque_else ::= ELSE codigo:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("bloque_else", parser.cont);
            parser.cont++;
            
            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);

            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | {:
                /*Se crea el nodo prinicipal*/
                Nodo nodo = new Nodo("VACIO", parser.cont);
                parser.cont++;
                /*Asignar el nodo al RESULT para continuar el recorrido*/
                RESULT = nodo;

            :}
            ;


/*==========================================CICLOS=====================================*/
/* Ciclos LOOP, While, y For */
ciclo_loop  ::= LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("ciclo_loop", parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | LOOP codigo:child1 salir_ciclo:child2 error END LOOP SEMICOLON
            | LOOP codigo:child1 salir_ciclo:child2 SEMICOLON error LOOP SEMICOLON
            | LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END error SEMICOLON
            | LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP error
            ;

ciclo_while ::= WHILE condicion:child1 LOOP codigo:child2 salir_ciclo:child3 SEMICOLON END LOOP SEMICOLON {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("ciclo_while", parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
            nodo.AddHijo((Nodo) child3);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;

            :}
            | WHILE condicion:child1 error codigo:child2 salir_ciclo:child3 SEMICOLON END LOOP SEMICOLON
            | WHILE condicion:child1 LOOP codigo:child2 salir_ciclo:child3 error END LOOP SEMICOLON
            | WHILE condicion:child1 LOOP codigo:child2 salir_ciclo:child3 SEMICOLON error LOOP SEMICOLON
            | WHILE condicion:child1 LOOP codigo:child2 salir_ciclo:child3 SEMICOLON END error SEMICOLON
            | WHILE condicion:child1 LOOP codigo:child2 salir_ciclo:child3 SEMICOLON END LOOP error
            ;

ciclo_for   ::= FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON{:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("ciclo_for", parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoId = new Nodo("ID", n1.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoNum = new Nodo("NUM", n3.toString(), parser.cont);
            parser.cont++;

            /*Nuevo Nodo: TERMINAL*/
            Nodo nodoNum2 = new Nodo("NUM",n5.toString(), parser.cont);
            parser.cont++;
            
            /*Se añaden los hijos*/
            nodo.AddHijo(nodoId);
            nodo.AddHijo(nodoNum);
            nodo.AddHijo(nodoNum2);
            nodo.AddHijo((Nodo) child1);
            nodo.AddHijo((Nodo) child2);
    
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | FOR error IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 error NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 error DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 error NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 error LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 error codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 error END LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON error LOOP SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END error SEMICOLON
            | FOR ID:n1 IN:n2 NUM:n3 DOSPUNTOS:n4 NUM:n5 LOOP codigo:child1 salir_ciclo:child2 SEMICOLON END LOOP error
            ;

salir_ciclo ::= EXIT WHEN condicion:child1 {:
            /*Se crea el nodo prinicipal*/
            Nodo nodo = new Nodo("salir_ciclo", parser.cont);
            parser.cont++;

            /*Se añaden los hijos*/
            nodo.AddHijo((Nodo) child1);
            
            /*Asignar el nodo al RESULT para continuar el recorrido*/
            RESULT = nodo;
            :}
            | error WHEN condicion:child1
            | EXIT error condicion:child1
            ;

/*==========================================PUT y GET===========================================*/
put ::= PUT PARIZQ:n1 NUM:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoNum = new Nodo("NUM", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoNum);
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error NUM:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 error PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 NUM:n2 error SEMICOLON
        | PUT PARIZQ:n1 NUM:n2 PARDER:n3 error

	    | PUT PARIZQ:n1 STRING:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;
        
        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoString = new Nodo("STRING", n2.toString().replaceAll("\"", ""), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoString);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error STRING:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 STRING:n2 error SEMICOLON
        | PUT PARIZQ:n1 STRING:n2 PARDER:n3 error

        | PUT PARIZQ:n1 CHAR:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoChar = new Nodo("CHAR", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoChar);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error CHAR:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 CHAR:n2 error SEMICOLON
        | PUT PARIZQ:n1 CHAR:n2 PARDER:n3 error

        | PUT PARIZQ:n1 TRUE:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoTrue = new Nodo("TRUE", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoTrue);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error TRUE:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 TRUE:n2 error SEMICOLON
        | PUT PARIZQ:n1 TRUE:n2 PARDER:n3 error

        | PUT PARIZQ:n1 FALSE:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoFalse = new Nodo("FALSE", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoFalse);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error FALSE:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 FALSE:n2 error SEMICOLON
        | PUT PARIZQ:n1 FALSE:n2 PARDER:n3 error

        | PUT PARIZQ:n1 ID:n2 PARDER:n3 SEMICOLON {:
        /*Se crea el nodo prinicipal*/
        Nodo nodo = new Nodo("PUT", parser.cont);
        parser.cont++;

        /*Nuevo Nodo: TERMINAL*/
        Nodo nodoID = new Nodo("ID", n2.toString(), parser.cont);
        parser.cont++;

        /*Se añaden los hijos*/
        nodo.AddHijo(nodoID);
        
        /*Asignar el nodo al RESULT para continuar el recorrido*/
        RESULT = nodo;
        :}
        | PUT error ID:n2 PARDER:n3 SEMICOLON
        | PUT PARIZQ:n1 ID:n2 error SEMICOLON
        | PUT PARIZQ:n1 ID:n2 PARDER:n3 error
	    ;

get ::= GET PARIZQ:n1 ID:n2 PARDER:n3 SEMICOLON {:
    /*Se crea el nodo prinicipal*/
    Nodo nodo = new Nodo("get", parser.cont);
    parser.cont++;

    /*Nuevo Nodo: TERMINAL*/
    Nodo nodoId = new Nodo("ID", n2.toString(), parser.cont);
    parser.cont++;

    /*Se añaden los hijos*/
    nodo.AddHijo(nodoId);
    
    /*Asignar el nodo al RESULT para continuar el recorrido*/
    RESULT = nodo;

    :}
    | GET error ID:n2 PARDER:n3 SEMICOLON
    | GET PARIZQ:n1 error PARDER:n3 SEMICOLON
    | GET PARIZQ:n1 ID:n2 error SEMICOLON
    | GET PARIZQ:n1 ID:n2 PARDER:n3 error
	;